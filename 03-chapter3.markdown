# 내부 아키텍처

기술은 마이크로서비스의 이로운 기능이지만, 정의된 특성은 아닙니다. 마이크로서비스는 주로 소형 빌딩, 다방면의 기업 비즈니스 팀과 관련이 있습니다. 흥미 있는 각 팀들은, 자연스레 최선의 기술로 자체 마이크로 소프트를 구축할 것입니다. 단일 마이크로서비스의 범위는 내부 작업이기에, Charter 3은 내부 아키텍처를 언급합니다

기술면에서는, 대부분의 마이크로소프트 기술 에코시스템 내 것들은 마이크로소프트 실행에 필수는 아니며, 기술 스택만 을 이용해 마이크로서비스를 실행시킬 수도 있습니다. 다시 말해, 마이크로서비스는 특정 기술 보다, 조직구조에 관련 된 것 이라는 겁니다. 기술은 마이크로서비스를 규모에 맞게 조작할 수 있게 합니다. 적절한 모니터링 시스템을 통해서는 마이크로서비스, 버전, 문제 발생 가능 인스턴스를 식별할 수 있습니다.

내/외부 아키텍처 소프트웨어의 대부분은 오픈소스입니다. 마이크로서비스는 해커 커뮤니티에서 만들어졌습니다. 기존 소프트웨어 공급업체는 해당 분야 관련 제품의 생산은 너무 느렸습니다. 내/외부 스택은 다양한 오픈소스 제품으로 구성되지만, 클라우드 공급업체는 일부 지원합니다.

기업 내 대부분의 기술 조달은 중앙 집중화 되어있습니다. CIO는 특정 데이터베이스, 프로그래밍 언어 등을 선택하여, 조직 구성원에게 사용을 강요할 것입니다. 최소 비용으로 갖춰진 조직에는 해당 전략이 타당합니다. 조달 부서는 공급업체로부터 최선의 가격을 짜내 제품 전문 지식을 갖춘 팀을 만들 수도 있지만, 이는 특정 계층에 구성원이 집중된 수평적 계층화를 강요하기에 마이크로서비스의 원리에는 완전히 반하고, 팀 간 결합으로 개발 속도는 현저하게 느려지게 됩니다.

오늘날 대부분의 기술 조달은 중앙 집중화 되어있는 반면, 마이크로서비스의 기술 조달은 분명하게 분산되어 있습니다. Chapter 2에서 논의된 바와 같이, 각 팀의 자체 스택 선택에는 충분한 자율성을 필요합니다. 이같은 자율성에는 운영 및 유지관리에 대한 책임이 수반되기에, 팀은 현명한 결정을 내려야만 합니다. 여유 있을 때, 새 버전 0.02프레임워크를 실행해 봐도 좋을 것 같습니다. 기존 기업의 기술 선택 자가 실제 기술자는 아니기떄문에, 조심스런 결정을 내리지않을 수도 있습니다.

## APIs

각 마이크로 서비스 팀은 하나 이상의 API를 전세계에 공개하기에, API 설계가 잘 되어있어야 합니다. 그러나 해당 Chapter에서는 내부 아키텍처에 초점을 맞춰, 외부 아키텍처에 대해 논의할 Chapter 4를 위하여, API게이트 웨이 및 API로드 밸런서에 대한 언급은 줄일 것입니다.

API들은 HTTP REST인 경우가 많지만, 필수는 아닙니다. 이는 우연히 최 하단 공통분모이며 가독성이 좋기에 사실상 표준이 되었습니다. JSON(JavaScript Object Notation)과 XML 중 어떤 형식을 선호하십니까?

JSON은 더 함축적이지만 읽기에도 어렵습니다. 특히, 데이터가 복잡하고 계층구조로 이루어진 때가 그렇습니다. XML은 보다 구조적이고 장황한 데이터에 맞습니다. 모든 최신 도구는 JSON과 XML으로 작동합니다만, XML의 광범위 사용 때문에 그에 대한 에코시스템을 많이 보게 될 것입니다.
두 방법 다 괜찮습니다! 고민하지 마십시오. 어느 쪽이든 조직에 적합하고 편한 것을 사용하십시오.

### Richardson Maturity Model

레놀드 리처드슨의 저서RESTful Web APIs (O’Reilly, 2013)은 REST API 설계를 위한 4단계 완성 모델을 설명하고있습니다. 재사용을 장려하려면, 가능한 이 계층을 기반으로 API를 설계해야 합니다.


#### Level 0: RPC

대부분의 REST 사용은 다음과 같습니다. HTTP는 단순히 전송 메커니즘으로 사용되어 두 가지 방법(하나는 로컬, 다른 하나는 원격) 간 데이터를 교환합니다. 이는 단일 애플리케이션에 가장 많이 사용됩니다.

각 완성도 수준을 보여주는 예시로, 재고 예약을 살펴보겠습니다. 인벤토리 질의를 위해, 당신은 단일 응용 프로그램에 HTTP POST를 수행할 것입니다. 해당 예시에서는 /App 뒤에 활용 가능하다고 간주합니다. 응용시스템 자체가 요청자의 인벤토리 질의 시도 식별을 위해, XML 구분을 면밀히 분석합니다. 이미, 여기서 애플리케이션 내 요청 전달 위치를 파악하기 위한 비즈니스 로직을 많이 요구하기에 이슈가 됩니다. 해당 예시에서는, 쿼리 인벤토리는 인벤토리 레벨을 반환하는 기능으로 재 매핑 되어야 합니다 :

```xml
HTTP POST to /App
<queryInventory productId="product12345" />
```

이는 당신에게 아래와 같이 응답할 것 입니다 :

```xml
200 OK
<inventory level="84" />
```

인벤토리 점유를 위해, 당신은 아래와 같이 할 수 있습니다:

```xml
HTTP POST to /App
<reserveInventory>
  <inventory productId="product12345" />
</reserveInventory>
```

유일하게 사용되는 HTTP 동사는 POST이며, 응용프로그램과 상호작용만 한다는 것을 알아차려야 합니다. 개별 서비스에 대한 개념은 없거나 (/Inventory) 서비스에 기능이 더해집니다(/inventory6reserveInventory).


#### Level 1: resources

level1은 전체 애플리케이션과 상호작용하는 것 보다, 특정 리소스(/Inventory)와 해당 리소스 내 개체(product122345)와의 상호작용을 요구합니다. 자원들은 깔끔하게 마이크로소프트에 다시 연결됩니다.

여기 level1을 통해 인벤토리에 질의하는 방법이 있습니다 :

```xml
HTTP POST to /Inventory/product12345
<queryInventory />
```

/App 이 아닌 _/Inventory_와 상호작용하는 것을 알아 둡니다. 또한, URL 에서 제품(Product1234)을 직접 참조하고있습니다.
그리고 당신은 응답 받을 것입니다 :

```xml
200 OK
<inventory level="84" />
```

실제 인벤토리를 점유하기위해서는, 아래와 같이 합니다 :

```xml
HTTP POST to /Inventory/product12345
<reserveInventory>
  <inventory qty="1" />
</reserveInventory>
```

인벤토리든 인벤토리 점유를 질의하든 관계없이, /inventory9/product12345 만 사용하는 것을 기억해 두십시오. 이는 /App으로 처리하는 것 보단 확실   히 개선되었지만, 이는 여전히 마이크로서비스를 입력으로 변환하고 올바른 함수로 전달하는 데에 많은 양의 비즈니스 로직을 요구합니다.

#### Level 2: HTTP verbs

Level 2는 Level1보다 약간 향상된 것으로, HTTP 동사를 사용합니다. 지금까지, 모든 HTTP 요청은 데이터 검색 또는 업데이트 여부에 상관없이 POST동사를 사용해왔습니다. HTTP동사는 정확하게 해당 목적을 위해서 만들어졌습니다. HTTP GET은 검색에 사용되고, HTTP PUT/POST는 생성 또는 업데이트에, HTTP DELETE는 삭제에 사용됩니다.

예제로 돌아가자면, 우리는 이제 현재 인벤토리에 질의할 때 제품을 위해 POST 보다 GET을 사용할 것입니다 :

```xml
HTTP GET to /Inventory/product12345
<inventory level="84" />
```

인벤토리 점유는 이전과 같습니다 :

```xml
HTTP POST to /Inventory/product12345
<reserveInventory>
  <inventory qty="1" />
</reserveInventory>
```

여기서, HTTP PUT 대 POST를 논의하는 것은 범위를 넘어서기에 생략하며, 새로운 인벤토리 기록을 생성하기위해, 아래와 같이 할 수 있습니다 :

```xml
HTTP POST to /Inventory
<createInventory>
  <inventory qty="1" productId="product12345" />
</createInventory>
```

표준화된 HTTP200 OK 응답이 아니라, 아래와 같이 돌려받을 수 있습니다 :

```xml
201 Created
Location: /Inventory/product12345
<inventory level="84" />
```

응답에서 반환된 신규 개체 위치로 호출자는 해당 위치의 알림 없이, 새 개체에 프로그래밍 방식으로 접근할 수 있습니다. 비록 이것이 HTTP동사를 도입한다는 점에서 레벨 1보다 향상되었지만, 여전히 그 객체 내 개별적 기능이 아닌 객체를 다루고 있습니다.

#### Level 3: HATEOAS (Hypertext As The Engine Of Application State)

Level3는 REST인터페이스 처리 레벨 중 가장 완성된 상태의 형식입니다. Level 3은 HTTP동사를 완전히 사용하고, URI로 객체를 식별하며, 프로그래밍 방식으로 객체들과 상호 작용할 지침을 제공합니다. API는 자동문서화되어 API와 API호출자의 상호 작용을 쉽게 하며, 그에 대한 정보 은닉도 제공 합니다. 이러한 형태의 자기문서화로 서버가 클라이언트 손상없이 URI들을 변경할 수 있습니다

Level 3/HATEOAS 는 실제 실행 시, 사용하기가 매우 어렵습니다. API와 API소비자의 작성은 어렵지만, 그 원칙들은 따를 가치가 있습니다.
인벤토리 예시로 돌아갑시다. 인벤토리 객체를 조회하기위해서, 당신은 아래와 같이 호출해야 합니다 :

```xml
GET /Inventory/product12345
```

그리고 당신이 응답 받는 것은 이와 같습니다 :

```xml
200 OK
<inventory level="84">
  <link rel="Inventory.reserveInventory" href="/Inventory/reserveInventory" />
  <link rel="Inventory.queryInventory" href="/Inventory/queryInventory" />
  <link rel="Inventory.deleteInventory" href="/Inventory/deleteInventory" />
  <link rel="Inventory.newInventory" href="/Inventory/newInventory" />
</inventory>
```

응답에는 인벤토리 개체에 사용 가능한 모든 작업 수행 법을 알려 주는 링크 태그가 포함됩니다. API 호출자는 인벤토리에 대해 알아야할 필요가 있으며, 인벤토리점유 키를 사용하여 URL을 조회할 수 있습니다 (/Inventory/reserveInventory). Level 3 준수를 위해 노력은 하지만, 높은 수준이니 부족해도 걱정하지 마십시오.

#### REST API Markup Languages
  REST API 모델링은 각 팀이 준수해야하는 최소 표준 중 하나여야 합니다. 실행중인 다양한 마이크로소프트서비스들은 Swagger나 RAML같은 REST API 마크 업 랭귀지를 채택했습니다. 이러한 형식은 RESTAPI의 표준이 되고 있으며, 이를 통해 서비스 구현체 내 뿐 아니라 업계 전체의 마이크로소프트서비스 간에도 상호 운용이 용이해 지고 있습니다.
이같은 표준 관련 도구 중 하나로 다음을 수행할 수 있습니다 :

	표준 형식을 사용하여 각 API를 모델링합니다.
	각 API를 문서화합니다. REST API를 위한 Java Docs처럼 생각해보세요. 문서는 각 마이크로 서비스를 구축하여, 자동으로 작성되고 발행 되어야합니다.
	그 이외 고급 툴을 사용하여, 각 API를 시각적으로 편집합니다.
	설계한 API와 맞추기 위한 클라이언트와 서버사이드 스텁을 생성하세요. 이는 구축 및 호출 마이크로서비스를 획기적으로 간소화합니다.

그림 3-1) Swagger를 사용한 인벤토리 예약 AP를 모델링 예시를 보여줍니다.
 
Figure 3-1. Swagger definition
그림 3-2에서 보여진 YAML 정의로부터 서버 및 클라이언트 측 스텁을 생성할 수 있게 됩니다.

Figure 3-2. Swagger server stubs
이러한 정의를 소스코드로 확인합니다. 업무에 가장 적합한 표준과 툴을 선택하십시오. 가장 중요한 것은 당신이 만들어내는 모든 마이크로서비스에서 이를 일관되게 사용하는 것입니다.

#### Versioning
  Chapter 2 에서 논의했듯이 마이크로 서비스의 정의 특징은 동일한 환경에서 동시에 여러 가지 버전의 마이크로 서비스를 지원하는 것입니다. 마이크로 서비스는 하나 또는 최대 수십 가지 버전을 배포 할 수 있으며 클라이언트는 검색하려는 마이크로 서비스 인스턴스의 주요 버전과 때로는 부 버전을 요청할 수 있습니다. 이로 인해 복잡성이 발생합니다.

 첫 번째 복잡성은 개발 자체에 있습니다. 여러 개의 메이저 코드 브랜치와 마이너 코드 브랜치를 지원해야한다.

  잠재적으로 소프트웨어를 작성할 때 기대할 수있는 표준 분기를 가지게됩니다. 이를 위해서는 풍부한 기능의 SCM (source control management system)을 충분히 사용해야합니다. 개발자는 버전 내에서 버전과 분기를 전환하는 데 능숙해야합니다. 더 복잡한 것은 있지만, 마이크로 서비스는 각 마이크로 서비스에 대한 코드베이스가 너무 작고 팀 크기가 너무 작기 때문에 팀 내 조정이 훨씬 적기 때문에 다소 편리합니다.

  마이크로 서비스를 구축한 후 환경에 배포가 필요합니다. 배포 메커니즘은 실행중인 코드의 여러 버전을 인식하고, 제대로 작동하지 않는 경우 신속하게 버전을 제거 할 수 있어야합니다. 퍼블릭 클라우드 벤더 및 많은 마이크로서비스 플랫폼이 이러한 기능을 제공하기 시작했습니다. 

  특정 버전의 마이크로 서비스 배포 후에는 사용 가능 여부를 클라이언트에게 알릴 필요가 있습니다. 머지않아 다루게 될 접근 방식에 따라, 클라이언트가 조회하고자하는 마이크로서비스 인스턴스의 특정 주요/ 부속 버전을 사용자가 질의 할 수 있게 해야 합니다. 단일 응용 프로그램은 버전에 관계없이 거의 항상 동일한 URL에서 조회됩니다.

  그런 다음, 버전 인식 자동 확장이 필요합니다. 마이클서비스 라이브 버전 1, 2, 3이 있다고 가정합니다. 버전2와 3은 모든 트래픽을 확보할 수 있습니다. 버전 1로가는 트래픽이 없기 때문에, 자동 확장 시스템이 모든 트래픽을 중지시킬 수 있습니다. 나중에 클라이언트가 버전 1을 호출해야 할 경우, 자동 확장 시스템이 응답으로 새 용량을 늘려야 할 수 있으며, 컨테이너 이미지를 검색하고 인스턴스화 하는 데 소요되는 시간에 따라 잠재적으로 몇 초 또는 몇 분이 걸릴 수 있습니다. 
  
  마지막으로, 모니터링은 모든 버전을 인식해야 합니다. 한 가지 버전의 마이크로 서비스 만 문제를 일으킬 수 있는데, 각 버전 별 기준 상태, 성능 및 기타 측정 항목을 볼 수 있어야합니다. 

#### Alternate Formats (대체 형식)
  지금까지는 기본 프로토콜이 HTTP라고 가정했습니다. 형식은 XML 또는 JSON입니다. HTTP와 XML 또는 JSON의 조합은 사람이 읽을 수 있고 쉽게 이해할 수 있고 프록시 및 API 게이트웨이와 같은 기존 제품에서 기본적으로 사용할 수 있기 때문에 잘 작동합니다..
이론적으로, 특히 클라이언트가 응답을 기다리는 경우에는 마이크로 서비스간에 동기 HTTP 호출을하는 경우가 거의 없습니다. 그러나 실제로는 너무 일반적입니다.

  최상의 최상의 성능을 위해서는 2 진 레벨 전송 시스템을 사용할 수 있습니다. 예를 들면 Apache Thrift, Apache Avro 및 Google 프로토콜 버퍼가 있습니다.

  예를 들어 Google의 프로토콜 버퍼는 XML보다 3 ~ 10 배, 20 ~ 100 배 빠릅니다. 인간의 가독성보다는 이러한 구현이 성능을 위해 최적화되었습니다.

#### Containers

  컨테이너는 대부분의 마이크로 서비스 배포에서 중요한 부분입니다. 컨테이너는 마이크로서비스에 필요하진 않지만, 이 둘은 거의 동시에 같은 시기에 접어들었으며 매우 상호 보완적입니다. 

  이 섹션에서는 단일 마이크로 서비스 용 컨테이너에 대해 설명합니다. 외부 복잡성에 대해 다루는 다음 섹션에서는 컨테이너를 배치하고 조정하는 방법에 대해 설명하기에, 이는 아마도 가장 큰 중점 이 될 것입니다.

  각 마이크로 서비스 팀의 가치는 하나 이상의 컨테이너에 마이크로 서비스를 깔끔하게 포장할 수 있다는 것입니다. 원자력, 불변성, 단위 코드, 구성, 런타임, 시스템, 라이브러리, 운영체제, 시작 및 중지 후크와 같은 환경을 통해 컨테이너를 촉진시킬 수 있습니다. 로컬에 배포된 컨테이너는 프러덕션 환경에서 완전히 동일한 방식으로 실행됩니다.

  응용 프로그램 패키징 외에도 컨테이너는 매우 가볍습니다. 종종 크기가 수백 기가 바이트 인 VM (가상 시스템) 이미지와 비교할 때 크기가 수백 메가에 불과합니다. 컨테이너가 인스턴스화되면 작성 가능한 얇은 계층이 기본 컨테이너 이미지의 맨 위에 생성됩니다. 작은 크기이며, 인스턴스화에 대한 혁신적 접근 방식을 사용하기에 VM을 인스턴스화하는 데 분 단위가 걸리는 데에 반해, 컨테이너는 몇 밀리 초 내에 프로 비저닝 및 실행이 가능합니다. 이를 통해 개발자는 로컬에서 마이크로 서비스를 실행하며, 개별 마이크로 서비스는 트래픽에 거의 실시간으로 반응하여 빠르게 확대 및 축소 할 수 있습니다. 다만, 많은 컨테이너들은 짧은 수명을 가집니다. Google은 일주일에 20 억 개의 컨테이너를 출시하며 장기 실행 컨테이너는 포함하지 않고 초당 3000 개 이상을 발매합니다만, 많은 컨테이너는 짧은 초 단위 동안만 살아있습니다. 그 때문에, 컨테이너 준비 및 제거에 약간의 오버 헤드가 발생합니다.
 
 Docker의 경우, Dockerfiles를 사용하여 선언적으로 컨테이너를 만듭니다. Dockerfiles는 소프트웨어 및 종속성을 설치/ 구성/ 실행하는 데 필요한 명령과 기본 Docker 이미지를 정의하는 간단한 YAML (YAML Mark not Language) 스크립트입니다. 다음은 매우 간단한 예입니다:
 
```xml
FROM centos:centos6
# Enable Extra Packages for Enterprise Linux (EPEL) for CentOS
RUN yum install -y epel-release
# Install Node.js and npm
RUN yum install -y nodejs npm
# Install app dependencies
COPY package.json /src/package.json
RUN cd /src; npm install
# Bundle app source
COPY . /src
EXPOSE 8080
CMD ["node", "/Inventory/index.js"]
```

  단순히 $ docker 빌드 -f / path / to / a / Docker 파일을 실행하여 빌드하십시오. 출력은 몇 밀리 초 만에 컨테이너로 인스턴스화 할 수 있는 이미지로 나옵니다. 컨테이너는 일단 빌드되면 항상 변경 가능해야 합니다. 새로운 버전의 코드를 배포하거나 응용 프로그램의 구성을 변경하거나 환경 변수를 설정해야하는 경우 Docker 파일을 업데이트하고 이미지를 다시 작성한 후 새 버전을 배포해야 합니다. 라이브 실행 컨테이너를 업데이트하지 마십시오. 변경 불가능한 인프라는 여러 환경에서 반복적으로 테스트하는 데 중요합니다. 불변 컨테이너를 사용하면 개별 컨테이너가 프로덕션 환경과 동일하게 로컬에서 실행됩니다.


