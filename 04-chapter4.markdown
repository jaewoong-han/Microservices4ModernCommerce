# 외부 아키텍처

외부 아키텍처는 마이크로 서비스 사이의 공간이며 가장 어려운 부분입니다. 이 책에서 지적했듯이, 마이크로 서비스는 내부의 복잡성에서 외부의 복잡성으로의 전환입니다.
대체로 마이크로 서비스의 외부 아키텍처는 개별 마이크로 서비스 간의 공간입니다. 개별 마이크로 서비스 팀의 책임이 아닌 것으로 생각하십시요.
외부 아키텍처에는 개별 마이크로 서비스가 배포되는 모든 인프라가 포함되며 마이크로 서비스를 찾고 연결하며 새로운 버전의 마이크로 서비스를 출시하고 마이크로 서비스 간 통신 및 보안을 제공합니다.
이것은 넒은 영역이며 복잡해 질수 있습니다.

외부 아키텍처는 최고의 프로그래머로 구성된 팀에서 가장 잘 처리 됩니다.
큰팀은 필요하지 않으며 정말 똑똑한 사람들로 구성된 작은 팀이 필요합니다.

```xml
 팀이 조직될때 체스의 그랜드 마스터를 이길만한큼 똑똑한 8살 짜리 아이들은 없다.
                                                           -Scott Alexander, 2015 
```

 당신이 세워야 할 목표는 각 마이크로 서비스 팀이 자체 마이크로 서비스에 집중할수 있도록 해주는 것입니다.


외부 아키텍처를 복잡하게 만드는 대부분은 새로운 기술 입니다.
 "마이크로 서비스(Micro Service)"라는 용어는 2013년 까지 널리 사용되진 않았습니다.
반면 내부 아키텍처를 지원하는 기술은 널리 확립되었습니다.
결국, 개별 마이크로 서비스는 단지 작은 응용프로그램입니다.


## 소프트 기반 인프라(Software-Based Infrastructure)

각 마이크로 서비스 팀은 자체 프로그래밍 언어, 런타임, 데이터 저장소 및 기타 상위 스택 요소를 선택할 수 있지만 모든 팀은 동일한 클라우드 공급자를 사용해야합니다.
  오늘날 주요 클라우드 플랫폼은 기술 및 상업 기능 측면에서 모두 "충분 함"입니다.

동일한 클라우드 공급자를 사용함에 있어 첫 번째 주요 이점은 여러 팀이 메시징, API 게이트웨이 및 서비스 검색과 같은 동일한 공유 리소스에 액세스 할 수 있다는 것입니다.
각 팀마다 독립적으로 선택할 수있는 기능이 있지만 일반적으로 팀 간 표준화를 원합니다. 
예를 들어, 메시징 시스템이 있는데 100 개의 다른 팀이 각각의 메시징 스택을 사용하고 싶지 않을 것입니다.
대신 중앙 집중식 팀은 하나의 구현을 선택하고 모든 마이크로 서비스 팀이 이 구현을 사용하게 해야 합니다. 이 수준에서 조각화하는 것은 의미가 없으므로 구현하기가 어렵습니다.
동일한 구현을 사용하는 모든 사람의 장점은 대기 시간이 거의 0이되는 경향이 있다는 것입니다.


## 컨테이너 오케스트레이션(Container Orchestration)

__tip)컨테이너 오케스트레이션 정의__  
오늘날의 개발에서, 애플리케이션은 더 이상 하나의 통일체가 아니라 특정 애플리케이션이 설계 의도대로 기능하도록 함께 작동해야 하는 수십 또는 수백 개의 느슨하게 결합되고 컨테이너화된 요소로 구성됩니다. 컨테이너 오케스트레이션은 개별 구성 요소와 애플리케이션 계층의 작업을 정리하는 과정을 의미합니다.

컨테이너는 개별 팀이 내부 아키텍처의 일부로 자체 마이크로 서비스를 구축하고 배포하는 데 사용됩니다.
컨테이너 오케스트레이션은 마이크로 서비스의 외부 아키텍처입니다.

간단히 말해서, 컨테이너 오케스트레이션은 물리적 호스트 또는 가상 호스트에서 개별 컨테이너를 실행하는 시스템입니다. 커맨드 라인에서 소수의 컨테이너를 관리하는 것은 매우 간단합니다. 서버로 SSH 연결하고, Docker를 설치하고, 컨테이너 이미지를 실행하고, 응용 프로그램의 호스트 / 포트를 노출합니다.  
단순하지만  몇 개이상의 컨테이너 이상에서는 작동하지 않습니다.
당신은 아마 수백, 수천개의 마이크로 서비스를 가지고 있을수 있습니다.
또한 각 마이크로 서비스는 다양한 버전과 여러 인스턴스를 포함할수도 있습니다. 하지만 이 마이크로 서비스들은 확장할 수 없습니다.

이 시스템은 또한 다음과 같은 일을 담당 할 수 있습니다.  
	• 새로운 버전의 코드 릴리스  
	• 준비 환경에 코드 배포  
	• 모든 통합 테스트 실행  
	• 프로덕션 환경에 코드 배포  
	• 서비스 레지스트리 - 마이크로 서비스 검색 및 라우팅  
	• 가장 좋은 인스턴스에 대한 호출자  
	• 로드 밸런싱 - 노드 내 및 여러 노드 간로드 균형 조정  
	• 네트워킹 오버레이 네트워크 및 동적 방화벽  
	• 자동 크기 조절 - 부하를 처리하는 컨테이너 추가 및 빼기  
	• 스토리지 - 컨테이너에 기존 볼륨 생성 및 연결  
	• 보안 - 식별, 인증 및 인증  

각각의 주제에 대해서는 다음절에서 더 자세히 다루겠습니다.

컨테이너 오케스트레이션은 기본적으로 마이크로 서비스와 함께 사용되는 새로운 형태의 플랫폼 서비스 (PaaS)입니다.
컨테이너 자체는 컨테이너 오케스트레이션 시스템이 관리하는 요소가 되어 매우 유연합니다.
컨테이너에 원하는 것을 넣을 수 있습니다. 전통적으로, PaaS는 엄격히 규정된 방법으로 접근하기 때문에 "독단적인 것"으로 간주됩니다.

 반면 컨테이너 오케스트레이션 시스템은 매우 덜 독단적이며 유연합니다.
유연성 이외에 인프라 활용도는 컨테이너 오케스트레이션 채택의 가장 중요한 요소입니다. 클라우드 환경에서도 VM (Virtual Machine)은 고정 된 CPU와 메모리를 가지고있는 반면, 단일 호스트에 배포 된 여러 컨테이너는 CPU와 메모리를 공유합니다.
컨테이너 오케스트레이션 시스템은 각 호스트 (실제 또는 가상)가 무리하지 않게 일하도록  보장합니다. 사용률은 90 % 또는 95 %로 유지되는 반면 VM은 일반적으로 10 %가 사용됩니다.
호스트의 사용률이 거의 100 %에 도달하면 컨테이너를 죽이고 사용률이 적은 다른 호스트에서 다시 시작할 수 있습니다.

클라우드와 마찬가지로 컨테이너 오케스트레이션은 모든 팀에서 사용해야하는 시스템입니다. 이러한 시스템은 설치, 배포 및 관리하기가 매우 어렵습니다. 설정 후 새로운 마이크로 서비스를 추가하는 데 드는 한계 비용은 기본적으로 0입니다. 각 마이크로 서비스 팀은 시스템을 쉽게 사용할 수 있습니다.

다음은 컨테이너 오케스트레이션 시스템이 수행 할 수있는 많은 역할 중 일부를 살펴 보겠습니다.

## 코드 배포(Releasing Code)
각 팀은 새로운 버전의 코드를 지속적으로 릴리스해야합니다.
각 팀은 자체 컨테이너를 구축하고 배포해야하지만 컨테이너 오케스트레이션 시스템을 사용하면됩니다. 모든 팀은 동일한 프로세스를 사용하여 코드를 배포해야하며 아티팩트(생성증거 ex-log)는 마이크로 서비스와 마찬가지로 단 한가지만 수행해야 하는 컨테이너 이어야 합니다.
예를 들어 응용 프로그램은 하나의 컨테이너에 있어야하며 데이터 저장소는 다른 컨테이너에 있어야합니다. 컨테이너 오케스트레이션 시스템은 모두 한 가지만 실행되는 컨테이너를 전제로합니다.

컨테이너 이미지를 빌드하기 위해서는  코드 /구성/런타임/시스템 라이브러리 /운영체제/시작및 중지 (메시지)이벤트를 포함 하여야 합니다. 이전에 논의 했듯이 이것은 소스 코드처럼 관리되는 Dockerfile YAML을 통해 관리되어 집니다.
Dockerfile은 주기적으로 테스트 및 업그레이드를 해야 하며 또한, 시작/중지 (메시지)이벤트도 테스트 해야 합니다.

(컨테이너)이미지를 만든 후에는 성공 / 실패 기준을 정해야 합니다.
예를 들어 배포가 성공적인지 테스트하기 위해 실행 할수 있는 자동화된 테스트는 무엇일까요?
가장 좋은 것은 API 호출 클라이언트를 통해 모든 API를 엄격히 검사 하는 것입니다.
무엇이 실패를 하게 만들까요? 또한 중요하지 않은 기능이 작동하지 않으면 전체 배포를 취소해야 할까요?

다음으로 당신의 자료를 빼오기 위한 전략을 정의해야 합니다.
당신은 이전 프로그램과 호환되는 마이크로서비스로 기존 구현을 대체 하고 있습니까?
아니면 이전 버전과 호환되지 않는 새로운 주요 버전을 출시 하고 있습니까?
배포가 한 번의 작업 (종종 "파란색 / 녹색"이라고 함)으로 진행되어야합니까? 아니면 점진적으로 단계별로 진행해야합니까? ex) 시간당 10 % (종종 "canary"라고도 함)씩 증가 
얼마나 많은 지역을 배포해야합니까? 얼마나 많은 오류 도메인이 있습니까? 얼마나 많은 데이터 센터가 있습니까? 어떤 데이터 센터입니까?

배포 후 컨테이너 오케스트레이션 시스템은로드 밸런서를 새 경로, 컷 오버 트래픽으로 업데이트 한 다음 컨테이너의 시작 / 중지 (메시지)이벤트를 실행해야합니다.
보시다시피,이 모든 것은 매우 복잡해질 수 있습니다. 적절한 컨테이너 오케스트레이션 시스템과 경험을 통해 몇 시간에 한 번씩 릴리스를 수행 할 수 있습니다  다시 말하지만, 컨테이너 오케스트레이션 시스템을 구축하는 데는 매우 전문화 된 소규모 팀이 필요합니다.
그런 다음 개별 팀에서 사용할 수 있습니다.

## 서비스 등록(Service Registry)
컨테이너 오케스트레이션 시스템이 호스트에 컨테이너를 배치하면 클라이언트는 컨테이너를 호출 할 수 있어야합니다. 그러나 몇 가지 복잡한 점이 있습니다.  

• 컨테이너는 몇 초, 몇 분 또는 몇 시간 동안 만 살 수 있다.
  그것들은 정의 상 일시적인 것이다.  
• 컨테이너는 종종 비표준 포트를 노출합니다.  
  예를 들어 포트 80을 통해 항상 HTTP를 누르는 것은 아니다.  
• 마이크로 서비스에는 많은 메이저 및 마이너 버전이 동시에 존재할 가능성이 높으므로 
  클라이언트는 요청에 버전을 명시해야합니다.  
• 수십, 수백 또는 수천 개의 다른 마이크로 서비스가 있습니다.  

이것들에는 클라이언트-측면과 서버-측면 2가지의 기본적인 접근 방식이 있습니다.

클라이언트 측 접근법은 개념적으로 간단합니다. 클라이언트 (API 게이트웨이, 다른 마이크로 서비스 또는 사용자 인터페이스 일 수 있음)는 독립형 서비스 레지스트리를 조회하여 완전한 엔드 포인트에 대한 경로를 요청합니다.
다시 말하지만, 클라이언트는 자신이 찾고있는 마이크로 서비스의 주요 버전과 서브 버전을 지정할 수 있어야합니다. 클라이언트는 해당 마이크로 서비스의 인스턴스에 대한 완전한 경로를 다시 가져오고, 그 다음에 다시 호출 할 수 있습니다.
 
이 접근법(클라이언트 측 접근법)의 주요 이점은 클라이언트와 끝점 사이에 중개자가 없다는 것입니다. 호출은 프록시를 순회(가로지르기)를 하지 않고 클라이언트에서 end-point(종점)으로 직접 이동합니다. 이방법은 클라이언트가 end-point(종점)을 조회하는 방법을 더욱더 풍부하게 해줍니다. 이 쿼리는 서비스 레지스트리의 정교함에 따라 버전 및 기타 서비스 품질 설정을 기술 한 공식 JSON 문서입니다.

이 방법의 가장 큰 단점은 클라이언트가 결합도의 한 형태인 각 마이크로 서비스의 조회 방법을 "학습"해야한다는 것입니다. 이것은 사용자가 알기쉽지 않습니다.
또한 각 마이크로 서비스의 구현은 다르기 때문에 각 마이크로 서비스는 쿼리의 필요성에 대한 자신만의 의미를 가지고 있어야 합니다. 뿐만아니라 클라이언트가 직접 통신하고 있는 end-point(종점)통신에 실패한 클라이언트가 다시 쿼리를 날려야 한다는 것입니다.

클라이언트 측 접근 방식이 도움이 될 수 있지만, 서버 측 방식은 오늘날 단순성과 광범위한 사용으로 인해 선호되는 경우가 많습니다. 이 방법은 기본적으로로드 밸런서를 사용하는 것입니다.
컨테이너 오케스트레이션은 컨테이너를 배치 할 때 부하 분산 장치에 끝점을 등록합니다. 클라이언트는 HTTP 헤더 또는 유사 항목을 지정하여 엔드 포인트에 대한 일부 요청을 작성할 수 있습니다.  
클라이언트 측로드 밸런싱과 달리 클라이언트는 엔드 포인트를 쿼리하는 방법을 알 필요가 없습니다. 로드 밸런서는 최상의 엔드 포인트를 선택합니다. 이방법은 매우 간단합니다.


## 로드밸런싱(Load Balancing)
서버 측 서비스 레지스트리를 사용하는 경우 로드밸런서가 필요합니다.
컨테이너를 배치 할 때마다로드 밸런서를 새로 만든 끝점의 IP, 포트 및 기타 메타 데이터로 업데이트해야합니다.

컨테이너 오케스트레이션 시스템에는 로컬 및 원격이라는 두 가지 수준의로드 균형 조정이 있습니다.

로컬 로드밸런싱은 단일 호스트 내에서의 로드밸런싱 입니다. 호스트는 물리적 서버이거나 가상화 될 수 있습니다. 호스트는 하나 이상의 컨테이너를 실행합니다. 컨테이너 오케스트레이션 시스템은 정기적으로 통신하는 마이크로 서비스의 인스턴스를 배포 할 수 있습니다
동일한 물리적 호스트로 __그림 4-1__ 은 개요를 나타냅니다.

![](https://github.com/l4zyg33k/Microservices4ModernCommerce/blob/master/figures/figure4_1.png)