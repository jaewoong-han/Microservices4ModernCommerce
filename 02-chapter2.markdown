# 마이크로서비스의 소개


### 마이크로서비스 정의 

    우리는 마이크로서비스의 high-level 특성에 대해 리뷰를 해볼것 입니다. 함께 정의 하는 특성이 어떤것이 있는지 살펴보겠습니다.

    단일 목적(Single Purpose)
        한 가지 일을 하고, 잘 해야 합니다.
    
    캡슐화(Encapsulation)
        각각의 마이크로서비스는 그들만의 자체 데이터를 소유하고 있습니다. 
        전체적인 상호작용은 잘 알려진 API들을 통해서 진행됩니다. (HTTP REST는 아니지만 자주 발생) 

    
    소유권(Ownership)
        2~15명으로 구성된 단일 팀(7명, 플러스 또는 마이너스 2명)의 사용자가 라이프 사이클 전체에 걸쳐 단일 마이크로 서비스를 개발, 구축 및 관리합니다.

    자율성(Autonomy)
        각각의 팀은 어떠한 이유를 위해 언제든지 협업없이 그들의 마이크로서비스를 개발하고 구축하는것이 가능합니다.
        각각의 팀은 또한 자체적인 구현 결정을 내리는데 있어 자유롭습니다.

    다수의 버전(Multiple versions)
        각 마이크로서비스의 다양한 버전은 같은 환경에서 동시에 존재할 수 있습니다.

    연출(Choreography)

        다수의 마이크로서비스에 걸친 작업은 분산된 방식으로 관리되며, 
        각 end-point는 해당 입출력을 충분하게 알 수 있을만큼 지능적입니다.

        그것들은 Top-down 방식의 workflow가 아니고 다수의 마이크로서비스의 경계에 걸쳐 트랜젝션을 관리합니다.


    궁극적인 일관성(Eventual consistency)
        일반적으로 모든 일관성을 갖게 됩니다.

        ※  마이크로서비스와 단일서비스를 비교하여 생각하는 것은 흥미롭습니다. 
            그러나 두가지 사이에는 각각의 단점이 있습니다. 
            마이크로서비스의 원칙이 맞다는 지지자는 거의 없습니다. 
            이 문서에 기술된 것은 교과서 적인 정의에 더 가깝습니다. 
            독자와 독자의 조직에 적합한 내용만 자유롭게 구현해야 합니다. 
            해당 문서를 독단적으로 진행하시면 안됩니다.


    이제 각각 더 깊이 알아보겠습니다.

#### 단일 목적(Single purpose)
    큰 규모의 단일 어플리케이션은 수천만 줄의 코드로 이루어져있고 그리고 수백개의 비즈니스 기능들로 구성되어 있습니다. 
    예를들어, 한개의 어플리케이션은 상품 관리, 재고, 가격, 프로모션, 쇼핑카트, 주문, 프로파일들 등등을 포함하고 있습니다. 
    반면에 마이크로서비스는 한가지 비즈니스 기능으로 구성되어 있습니다.
    '한 가지 일을 하고 그 일을 잘하자'라는 Unix의 기본 원칙으로 돌아가보면, 마이크로서비스는 이러한 원칙을 정의하고 있습니다. 
    한 가지 일을 잘 하면 팀이 집중 할 수 있고, 복잡성은 최소한으로 줄일 수 있습니다.

    시간이 지날수록 어플리케이션이 점점 추가되고 많은 기능이 생기는 것은 자연스러운 현상입니다.

## 마이크로서비스의 이점(Advantages of Microservices)
    마이크로서비스는 많은 이점을 제공합니다. 그 중 몇개를 구체적으로 짚어보겠습니다.

### 출시기간 단축
    새로운 기능들의 출시기간 단축은 마이크로서비스의 가장 중요한 이점입니다.
    초기에 시장에 진입하는 전체적인 시간은 마이크로서비스로 도입된 부가적인 선행 복잡성 때문에 더 길어질 수 있습니다. 
    하지만 도입되고 난 이후에는, 각 팀은 독립적으로 혁신하고 매우 빠르게 출시할 수 있습니다.(자료 2-13)

    ![그림 2-13. 각 팀은 독립적으로 혁신할 수 있습니다.](https://raw.githubusercontent.com/l4zyg33k/Microservices4ModernCommerce/master/figures/fig2-13.png)
    그림 2-13 각 팀은 독립적으로 혁신할 수 있습니다.

    시장에 빠르게 진입할 수 있는 기능을 갖는 것은 사업에서 상당히 중요한 이점을 가질 수 있습니다.
    만약 출시를 위한 생산이 분기별로 이뤄지고 올바르게 바로잡기 위해 4번의 반복이 필요하다면, 결국 바로 잡는데에 1년의 시간이 소요됩니다.
    만약 출시가 매일 이뤄지고 바로잡기 위해 4번의 반복이 필요하다면, 단 4일이 소요됩니다.
    빠른 반복뿐 아니라, 마이크로서비스는 실패를 더 빠르게 발생시킬 수 있습니다.
    때때로, 기능들은 예상대로 작용하지 않습니다. 출시 취소되기까지 한 분기를 기다리는 것 보다 즉시 취소할 수 있는 것이 낫습니다.

    마이크로서비스는 의존도를 제거하기 때문에 빠릅니다. 마이크로서비스로 다음과 같은 사항을 고려할 필요가 없습니다.
    - 일원화된 구조 검토 위원회로부터의 구조적 승인
    - 경영위원으로부터 출시 승인
    - 수평적 의존성 - 예를들어, 공유된 DB수정을 위해 DBA를 기다릴 필요가 없고, 공급산출을 위해 영업활동이 필요가 없음
    - 수직적으로 의존적인 다른팀과 출시 조정 - 예를들어, 재고 마이크로서비스는 상품 마이크로서비스 팀과 나란히 출시할 필요가 없을 것입니다.
    - 이러한 기능을 수행하는 QA, 보안팀 등 각 팀의 승인

    이러한 일원화된 기능을 위한 책임은 자급자족하도록 기술을 갖고 있는 각각의 작은 팀에게 전가됩니다.
    각 팀은 단순히 input(보통 이벤트나 API호출) 과 output(보통 이벤트나 API들)만 상관하게 됩니다. 의존성을 제거하는 것은 개발 속도를 급격하게 증가시킵니다.

### 진정한 옴니채널 커머스
    완전한 마이크로서비스 도입은 세분화된 여러 비즈니스 기능을 위해 개별 API를 갖는 것을 의미한다.
    이러한 API들 위에 있는 사용자 인터페이스는 일회용이 될 것입니다.
    차후에 Apple 혹은 Facebook은 전체적인 백엔드를 구성하지 않고 쉽게 만들 수 있는 새로운 타입의 어플리케이션을 도입할 것입니다.
    새로운 사용자 인터페이스가 며칠내에 구축될 수 있습니다.

### 더 낫고 덜 복잡한 코드
    마이크로서비스는 하나의 마이크로서비스가 한 비즈니스 기능을 수행하기 때문에 훨씬 나은 코드를 만드려고 노력합니다.
    큰 단일 어플리케이션은 수천만 라인의 코드로 이뤄지는 반면 한 마이크로서비스는 수천의 라인으로 이뤄질 수 있습니다.
    물론, 적은 코드는 훨씬 규모가 큰 코드보다 더 나을 것입니다.

    코드도 소규모의 팀이 소유하면서 책임지는 구조이기 때문에 더 낫습니다. 코드베이스는 작은팀의 모습입니다.
    다른 모든사람들처럼 개발자들 또한 동료와 상급자에게 잘보이고 싶어합니다.

    마지막으로, 각 마이크로서비스팀은 질 좋은 코드를 작성하는데에 강한 의욕이 있습니다.
    전형적인 단일 어플리케이션을 운영하면서 시스템이 작동하지 않아 한밤 중에 연락을 받지 않을 수 있도록 소스를 작성합니다. 그것이 운영의 역할입니다.
    하지만 마이크로서비스를 이용하면, 각각의 소규모 팀은 효율성에도 책임지는을 갖고 있습니다.
    주로 가장 바쁜 시간대에 수정해야 했던 조잡한 코드를 확인하기 쉽습니다.
    옆자리에 앉아있고 점심을 같이 먹는 동료가 매일매일 확인해주는 것은 어렵습니다.

### 책임
    각 소규모 팀은 단일 마이크로서비스를 도입할 때부터 서비스를 종료할 때까지 갖고있습니다. 각 팀은 아키텍쳐를 만들고 구현, 기술적 결정에 완전한 자유를 갖습니다.
    모든 자유는 각 팀, 그팀의 각 구성원들이 책임이 있다는 것을 의미합니다.
    만약 어떤 팀이 새로운 오픈 소스 프로젝트를 선택했지만 6개월 만에 끝나고 교체되어야 한다면, 그 팀은 그것을 수정할 책임이 있습니다.
    반대로, 팀의 마이크로서비스가 100%의 시간 동안 이용가능하고 0%의 오류 비율을 갖고있다면, 그 팀은 좋은 선택을 한 것에 대해 단독으로 인정받을 수 있습니다.

    세계와의 마이크로서비스 인터페이스는 API이기 때문에, 시간경과에 따른 유용성, 오류 비율, 성능을 정량적으로 측정하는 것은 상당히 쉽습니다.
    또한, 한 팀의 주요업무, 기능 등의 측면에서 처리량을 측정하기에도 쉽습니다.
    하나의 작은 어플리케이션을 만들어 하나의 비즈니스 문제를 해결하고 보통 한개의 API를 공개합니다.

    마이크로서비스는 직원의 질을 높이면서 뜻하지 않은 부작용을 갖고 있습니다.
    규모가 큰 팀에서, 가장 못하는 직원은 쉽게 숨을 수 있습니다. 아마 그들은 문서작업을 하거나, 변경요청을 승인하거나, 다른 관리적인 업무를 수행할 것입니다.
    몇몇은 그들의 코드를 다시 수정하는 작업을 할 것입니다. 하지만 작은 팀에서, 일을 잘 못하는 직원은 숨을 수 없습니다.
    만약 한팀에 세명의 개발자가 있고 한명이 그의 제 역할을 하지 못한다면, 나머지 두 개발자와 나머지 직원들에게 분명하게 보일 것입니다.
    기량이 저조한 직원의 경우 자발적으로 혹은 비자발적으로 떠나게됩니다. 기량이 뛰어난 직원의 경우 자유와 책임의 문화가 매력적일 것입니다.

### 강화된 분야 전문지식
    마이크로서비스는 비즈니스 기능들을 세밀한 서비스로 분리되는 것을 요구합니다.
    커머스시스템에서 마이크로서비스는 프로모션, 가격책정, 상품 카탈로그, 재고관리, 장바구니, 주문을 비롯한 다른 요소들을 가질 것입니다.
    각 작은 팀은 하나의 단일 마이크로 서비스를 도입 부터 서비스 종료시 까지 소유합니다.

    각 팀은 종종 한명 혹은 두명의 비즈니스 분석가, 상품 관리자, 혹은 기능을 살펴보는 책임을 가지면서 덜 기술적인 역할을 가진 사람을 포함합니다.
    그런 사람들은 하나의 작은 기능을 살펴보기 때문에 분야에 구체적인 전문지식을 매우 깊게 발전시킬 수 있습니다.
    예를들어, 비즈니스 전문가는 프로모션에 관해 그 회사의 전문가가 될 책임이 있습니다.
    단일 어플리케이션으로 비즈니스 분석가는 큰 부분을 맡으려는 경향이 있고, 주기적으로 다른 기능에 할당되고 있습니다.
    마이크로서비스로 한 분야에 매우 깊은 비즈니스 전문지식을 발전시키기 쉽습니다.

    기술진들도 비즈니스를 지원하는데 필요한 기술적 전문지식과 알고리즘을 매우 깊게 개발할 수 있습니다.
    예를들어, 재고관리 마이크로서비스를 구축하는 팀은 분산된 광범위한 전문지식을 개발할 수 있습니다.

### 쉬워진 아웃소싱
    모든것들이 밀접하게 연결되어 있기 때문에, 전통적인 단일 어플리케이션을 위한 개발, 운영 및 QA와 같은 역할은 아웃소싱하기 어렵습니다.
    예를들어, 새로운 지불모듈을 구축하기 위해 타사 시스템을 도입하는 것은 단 며칠이 소요될 것이지만,
     개발환경을 수립하고 공유된 DB에 변경하는 프로세스를 배우고 코드를 배포하는 등 수주가 소요될 것입니다.

    마이크로서비스는 아웃소싱하기 매우 쉽게 만들어줍니다. 지불모듈 도입 대신, 시스템 통합자는 하나의 단일 API를 보여주는 지불 마이크로서비스를 만드므로써 해결할 수 있습니다.
    그 시스템 통합자는  지불 마이크로서비스를 구축하고 서비스로 관리하거나 다른 마이크로서비스들과 같이 관리할 수 있는 사람에게 넘길 수 있습니다.
    이러한 방식으로 아웃소싱하면 서로 다른 팀 간의 커뮤니케이션 없이 수십 혹은 수백개의 마이크로서비스들을 병렬적으로 개발할 수 있습니다.

    시스템 통합자를 고용하기보다 API는 타사소프트웨어 벤더들을 통해 구매될 수 있습니다. 
    예를들어, 서비스로 지불API를 제공하는 벤더들이 있습니다. 혹은 상품 추천이 하나의 서비스로 제공될 수 있습니다.
    이 벤더들은 단순히 한 서비스로 사용될 수 있는 서비스로서 매우 차별화된 기능을 구축할 수 있습니다.

### 보안
    대규모 단일 어플리케이션에서 보안은 사후에 고려되는 경우가 대다수입니다. 불가피하게 어플리케이션은 개발되고 종종 UI에서만 나중에 보안에 대한 작업이 이뤄집니다.
    한 어플리케이션이 손상된 경우, 전체 어플리케이션에서 어떠한 기능이든 호출할 수 있습니다.
    적절한 보안이 구현된다고 하더라도 개발자들이 사용하도록 강요할 수 있는 실질적인 방법은 없습니다. 많은 개발자들이 코드가 복잡하고 지저분하기 때문에 구현하지 않습니다.

    마이크로서비스는 매우 다릅니다. 각 마이크로서비스는 하나 혹은 두개의 API로 작게 쪼개진 비즈니스 기능을 보여줍니다.
    정확하게 누가 혹은 어떤 것이 각 API를 호출하고 있는지 알기 쉽습니다.
    어플리케이션 단에서 보안을 다루는 것보다 API 게이트웨이 혹은 API 로드밸런서를 사용하는 것이 낫습니다.
    이러한 상품들은 사용자, 역할과 조직과 같은 요소들을 정의할 수 있게 합니다. 하나의 API에서 다른 API로의 호출은 API 게이트웨이나 API 로드밸런서를 통하여 이뤄집니다.
    각 요청은 도착지까지 도착할 수 있는지 확인하기 위하여 룰셋으로 평가됩니다.
    예를들어, 마케팅팀의 Jenn은 고객관련 마이크로서비스로 HTTP GET 요청만 가능하지만, 주문관련 마이크로서비스는 HTTP POST와 GET 요청이 가능합니다.
    기본적으로 API 게이트웨이나 API 로드밸런서에 deny-all 정책을 구현하고 모든 요청을 강제로 전달할 수 있습니다.

    마이크로서비스는 또한 보안관점에서 더 나은데, 각 마이크로서비스는 독립적으로 구축되며 종종 공용클라우드 내에 전용망에 구축됩니다.
    만약 공격자가 하나의 마이크로서비스에 접근하려고 한다면, 다른 마이크로서비스를 쉽게 얻지 못할 것입니다. 이것이 *`bulkheading(격벽, 칸막이)`*이라고 불립니다.
    단일 어플리케이션이 탈취된다면, 공격자는 전체적인 데이터베이트와 모든 어플리케이션 코드에 접근할 것입니다. 더 큰 손해를 입을 수 있습니다.


## 마이크로서비스의 단점(Disadvantages of Microservices)
    비록 마이크로서비스가 확실히 이점들을 가지고 있지만, 이와 마찬가지로 단점 또한 가지고 있습니다.
    마이크로서비스의 목표는 새로운 기능의 제공 속도를 높이는데 있습니다. 비용을 줄이는 것이 아닙니다.
    새로운 기능을 신속하게 출시하는 것은 잠재적으로 더 높은 마이크로서비스 개발비용을 상쇄하고도 남을 것입니다.

### 외부 복잡성의 어려움
    마이크로서비스는 종종 외부 복잡성을 위해 내부를 희생시키는것으로 여겨집니다.
    단일 어플리케이션은 내부가 복잡한 반면 마이크로서비스의 내부는 간단합니다. 단일 어플리케이션의 외부는 단순한 반면에 마이크로서비스의 외부 복잡성은 까다롭습니다.
    이러한 차이를 통해 마이크로서비스팀은 새로운 기능을 매우 빠르게 구축하고 구축할 수 있습니다. 하지만, 마이크로서비스간의 상호작용을 관리하는 비용을 수반합니다.

    마이크로서비스의 외부 복잡성에 대한 예시는 다음과 같습니다.
        데이터 동기화
            동기식 또는 비동기식 으로 마이크로서비스간 데이터 복사

        보안
            누가/어떤것이 각각의 End Point를 호출할 수 있습니까? 어떤 데이터를 전달받을 수 있는가? 어떤 동작만을 허용할 것입니까?

        확인
            어떤 마이크로서비스가 사용가능합니까? 특정 마이크로서비스에서 사용되어야 하는 메시지는 어떤 것입니까?

        버전 관리
            특정한 API나 특정 API 구현 버전을 어떻게 관리할 것입니까?

        진부한 데이터
            어떤 마이크로서비스가 주어진 데이터를 기록할 진짜 시스템입니까?

    디버깅도 더 어렵습니다. 13.2버전 장바구니 마이크로서비스와 19.1버전의 재고관리 마이크로서비스가 서로 이상하게 연관되어 있다면 어떻게 할까요?
    언제든지 동시에 다양한 버전의 마이크로서비스들이 동일한 환경에 존재하는 것을 기억해야 합니다. 
    이러한 사항으로 모든 상관관계를 테스트 하는 것은 불가합니다.
    그리고 마이크로서비스의 모든 상호작용에 대한 테스트를 중앙에서 관리하는 것은 마이크로서비스 사상에 반하는 것입니다.

### 조직 성숙도(Organizational Maturity)
    조직은 탄탄한 구조, 문화와 기술적 역량을 가지고 있어야 합니다. 각각 하나씩 살펴보겠습니다.

    우리가 이미 살펴본 것 처럼, 조직의 구조가 소프트웨어 생성을 어떻게 해야하는지 정합니다.
    계층을 중심으로 하는 중앙화 된 조직은 계층화 된 단일 어플리케이션 생성을 지향합니다.
    단순한 변경일 지라도 계층 전체에 광범위한 조정이 필요하기 때문에 시간이 더 소요됩니다.
    마이크로서비스를 만들기를 원하는 조직을 위한 더 나은 구조는 재품을 재구성 하는 것 입니다.
